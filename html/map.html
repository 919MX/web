<!DOCTYPE HTML>
<html>
<head>

  <title>919.MX</title>
  <meta name="description" content="919.MX es una herramienta que ayuda a coordinar los esfuerzos de las organizaciones involucradas en la reconstrucción de México.">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, minimum-scale=1, maximum-scale=1" />

  <link rel="stylesheet" type="text/css" href="/styles/map.css">
  <link rel="shortcut icon" type="image/ico" href="/assets/img/favicon.ico"/>

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-108487748-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-108487748-1');
  </script>

  <script src='https://api.mapbox.com/mapbox-gl-js/v0.40.0/mapbox-gl.js'></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v0.40.0/mapbox-gl.css' rel='stylesheet' />
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>

</head>

<body>

<header id="beta">
  <a id="logo" href="/"><img src="/assets/img/logo.svg" width="108px" height="auto" alt="Logo" /></a>
  <select>
    <option value="" selected="selected">Marginación social</option>
    <option value="severe">MUY GRAVE</option>
    <option value="high">GRAVE</option>
    <option value="medium">MEDIO</option>
    <option value="low">MENOR</option>
    <option value="minimal">MÍNIMO</option>
  </select>
</header>

<div id='map'>
  <div class='features'>
    <fieldset>
      <input id='feature-filter' type='text' placeholder='Buscar localidades' />
    </fieldset>
    <div id='feature-list' class='list'></div>
  </div>
  <div class='legend'>
    <div class='legend-header'>Localidades por afectación estimada</div>
    <div class='legend-item dmg-severe'><span class="label">Muy Grave</span></div>
    <div class='legend-item dmg-high'><span class="label">Grave</span></div>
    <div class='legend-item dmg-medium'><span class="label">Medio</span></div>
    <div class='legend-item dmg-low:'><span class="label">Menor</span></div>
    <div class='legend-item dmg-minimal'><span class="label">Mínimo</span></div>
    <div class='legend-item dmg-unknown'><span class="label">Sin Datos</span></div>
  </div>
</div>

<<<<<<< HEAD

=======
<div class='legend'>
  <div class='legend-header'>Localidades por afectación estimada</div>
  <div class='legend-items-container'></div>
</div>
>>>>>>> 2c625b8e709510f9f1b9830d817de2183ecdb6fc

<script type="text/javascript">
mapboxgl.accessToken = 'pk.eyJ1Ijoia3lsZWJlYmFrIiwiYSI6ImNqOTV2emYzdjIxbXEyd3A2Ynd2d2s0dG4ifQ.W9vKUEkm1KtmR66z_dhixA'
const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/kylebebak/cj95wutp2hbr22smynacs9gnk',
  zoom: 7.5,
  center: [-95.4042505, 16.6073688]
})

// creates a popup, but doesn't add it to map yet
const popup = new mapboxgl.Popup({
  closeButton: false
})

let localities = [] // holds all locality features for filtering
let _localities = [] // filtered localities
const numList = 500

const damageGrade = (feature) => {
  const levels = [
    [10, 'minimal'],
    [50, 'low'],
    [250, 'medium'],
    [1250, 'high'],
    [Number.MAX_SAFE_INTEGER, 'severe'],
  ]
  const { total } = feature.properties
  if (total === undefined || total === null || total === '') {
    return 'unknown'
  }
  for (let l of levels) {
    if (total < l[0]) {
      return l[1]
    }
  }
  return 'unknown'
}

const damageGradeMeta = {
  unknown: {label: 'SIN DATOS', color: '#999'},
  minimal: {label: 'MÍNIMO', color: '#ff0'},
  low: {label: 'MENOR', color: '#db0'},
  medium: {label: 'MEDIO', color: '#d80'},
  high: {label: 'GRAVE', color: '#d40'},
  severe: {label: 'MUY GRAVE', color: '#f00'},
}

const filter = $('#feature-filter')
const list = $('#feature-list')

const showPopup = (feature) => {
  popup.setLngLat(feature.geometry.coordinates)
    .setHTML(renderPopup(feature))
    .addTo(map)
}

const renderPopup = (locality) => {
  const { stateName, munName, locName, habit, notHabit, destroyed, margGrade } = locality.properties
  const total = habit + notHabit + destroyed
  return `
    <h3>${locName}</h4>
    <h5>${stateName}, ${munName}</h6>
    <div><span class="popup-label">TOTAL DAÑADOS</span> <span class="popup-value">${total}</span></div>
    <div><span class="popup-label">HABITABLES</span> <span class="popup-value">${habit}</span></div>
    <div><span class="popup-label">NO HABITABLES</span> <span class="popup-value">${notHabit}</span></div>
    <div><span class="popup-label">DESTROZADOS</span> <span class="popup-value">${destroyed}</span></div>
    <div><span class="popup-label">GRADO MARGINACIÓN</span> <span class="popup-value">${margGrade}</span></div>
  `
}

const renderLegend = (localities) => {
  const legend = $('.legend-items-container')
  const counts = {
    severe: 0,
    high: 0,
    medium: 0,
    low: 0,
    minimal: 0,
    unknown: 0,
  }

  for (let l of localities) {
    counts[l.properties.dmgGrade] += 1
  }
  const items = Object.keys(counts).map(key => {
    const { label, color } = damageGradeMeta[key]
    return `<div class='legend-item'>
      <div class="circle" style="background-color: ${color}"></div>
      <span class="label">${label}</span>
      <span class="count">${counts[key]}</span>
    </div>`
  })
  legend.html(items.join('\n'))
}

const renderList = (localities) => {
  // clear any existing listings
  list.html('')
  for (let l of localities) {
    const item = renderListItem(l)
    item.hover(
      () => {
        showPopup(l)
      },
      () => {
        popup.remove()
      }
    )
    list.append(item)
    item.on('click', () => {
      map.setCenter(l.geometry.coordinates)
    })
  }
}

const renderListItem = (locality) => {
  const { locName, stateName, margGrade, total = '?', dmgGrade } = locality.properties
  const item = $(`<div class="list-item dmg-${dmgGrade}">`)

  const header = $('<div class="list-item-header">')
  header.text(`${locName}, ${stateName}`)

  const metrics = $('<div class="list-item-metrics">')
  metrics.html(`
    <div><span class="label">MARG. SOCIAL</span> <span class="value">${margGrade || '?'}</span></div>
    <div><span class="label">VIVIENDAS DAÑADAS</span> <span class="value">${total}</span></div>
  `)

  item.append(header)
  item.append(metrics)
  return item
}

const cleanAccentedChars = (s) => {
  s = s.replace(/[áÁ]/g, 'a')
  s = s.replace(/[éÉ]/g, 'e')
  s = s.replace(/[íÍ]/g, 'i')
  s = s.replace(/[ñÑ]/g, 'n')
  s = s.replace(/[óÓ]/g, 'o')
  s = s.replace(/[úÚüÜ]/g, 'u')
  return s
}

// splits text into whitespace delimited lowercase words
const toLowerWords = (text) => (text || '')
  .toLowerCase()
  .replace(/[^\s0-9a-z]/gi, '')
  .split(/\s+/g)
  .filter(x => x.length > 0)

const tokenMatch = (h, n) => {
  const needles = toLowerWords(cleanAccentedChars(n))
  const haystack = toLowerWords(cleanAccentedChars(h))

  outer:
  for (let n of needles) {
    for (let i = 0, l = haystack.length; i < l; i++) {
      if (haystack[i].indexOf(n) >= 0) {
        haystack.splice(i, 1)
        continue outer
      }
    }
    return false
  }
  return true
}

const deduplicate = (features, comparatorProperty) => {
  const existingFeatureKeys = {}
  // Because features come from tiled vector data, feature geometries may be split
  // or duplicated across tile boundaries and, as a result, features may appear
  // multiple times in query results.
  const uniqueFeatures = features.filter((el) => {
    if (existingFeatureKeys[el.properties[comparatorProperty]]) {
      return false
    } else {
      existingFeatureKeys[el.properties[comparatorProperty]] = true
      return true
    }
  })

  return uniqueFeatures
}

/**
 * Comparator for localities `a` and `b`, which assigns greater priority to
   localities with high "marginación social" and many damaged buildings.
 */
const compareLocalities = (a, b) => {
  const { total: ta } = a.properties
  const { total: tb } = b.properties
  if (isNaN(parseFloat(ta))) return 1
  if (isNaN(parseFloat(tb))) return -1
  return parseFloat(tb) - parseFloat(ta)
}

map.on('load', () => {
  map.addLayer({
    id: 'damage',
    type: 'circle',
    source: {
      type: 'vector',
      url: 'mapbox://kylebebak.8ysz50ul'
    },
    'source-layer': 'oaxaca-26oct-6wh485',
    paint: {
      'circle-radius': {
        property: 'total',
        type: 'exponential',
        stops: [
          [1, 5],
          [15000, 35]
        ]
      },
      'circle-color': {
        property: 'total',
        stops: [
          [0, '#ff0'],
          [10, '#db0'],
          [50, '#d80'],
          [250, '#d40'],
          [1250, '#f00'],
        ]
      },
      'circle-opacity': 0.75,
    }
  })

  map.on('mousemove', 'damage', (e) => {
    // change the cursor style as a ui indicator
    map.getCanvas().style.cursor = 'pointer'

    // populate the popup and set its coordinates based on the feature
    const feature = e.features[0]
    showPopup(feature)
  })

  map.on('mouseleave', 'damage', () => {
    map.getCanvas().style.cursor = ''
    popup.remove()
  })

  filter.on('keyup', (e) => {
    // filter visible features that don't match the input value
    const filtered = localities.filter((feature) => {
      const { locName, stateName } = feature.properties
      return tokenMatch(`${locName} ${stateName}`, e.target.value)
    })
    render(filtered)
  })

  map.on('data', (data) => {
    if (localities.length > 0) { return } // only call this function on initialization

    if (data.dataType === 'source' && data.isSourceLoaded) {
      const features = map.querySourceFeatures('damage', {sourceLayer: 'oaxaca-26oct-6wh485'})
      localities = deduplicate(features, 'cvegeo')
      localities.sort(compareLocalities)
      for (let l of localities) {
        const dmgGrade = damageGrade(l)
        l.properties.dmgGrade = dmgGrade
      }
      render(localities)
    }
  })
})

/**
 * Renders list items, legend and features layer every time "state" changes.
 */
const render = (filtered) => {
  // populate the sidebar with filtered results
  renderList(filtered.slice(0, numList))

  renderLegend(filtered)

  // set the filter to populate features into the layer
  map.setFilter('damage', ['in', 'cvegeo'].concat(
    filtered.map((feature) => {
      return feature.properties.cvegeo
    })
  ))
}
</script>

</body>

</html>
